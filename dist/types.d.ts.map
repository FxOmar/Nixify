{"mappings":"AACA;IACE,UAAU,CAAC,EAAE;QAAE,CAAC,IAAI,EAAE,MAAM,GAAG,MAAM,CAAA;KAAE,GAAG,MAAM,CAAC;CAClD;AAED;IACE,IAAI,EAAE,MAAM,CAAC,MAAM,EAAE,OAAO,CAAC,CAAC;IAE9B,OAAO,EAAE,GAAG,CAAC;IACb,MAAM,EAAE,MAAM,CAAC;IACf,UAAU,EAAE,MAAM,CAAC;IACnB,MAAM,EAAE,OAAO,CAAC;CACjB;AACD;IACE,CAAC,IAAI,EAAE,MAAM,GAAG,CACd,IAAI,EAAE,MAAM,EACZ,OAAO,CAAC,EAAE,qBAAqB,KAC5B,OAAO,CAAC,iBAAiB,CAAC,CAAC;CACjC;AAED;IACE,UAAU,CAAC,EAAE,MAAM,CAAC;IACpB,IAAI,CAAC,EAAE,QAAQ,GAAG,eAAe,CAAC;IAClC,IAAI,CAAC,EAAE,IAAI,CAAC;IACZ,OAAO,CAAC,EAAE,OAAO,CAAC;IAClB,YAAY,CAAC,EAAE,MAAM,CAAC;CACvB;AA+GD;;;;;;GAMG;AACH,kCAAkC,MAAM,CAAC,EAAE,gBAAgB,GAAG,gBAAgB,CA6B7E;AAED,QAAA,MAAM,IAAI,kBAAsB,CAAC;AAEjC,eAAe,IAAI,CAAC","sources":["src/src/index.ts","src/index.ts"],"sourcesContent":[null,"// TODO: Move all interfaces to a separate file.\ninterface OptionsInterface {\n  PREFIX_URL?: { [name: string]: string } | string;\n}\n\ninterface ResponseInterface {\n  data: Record<string, unknown>;\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  headers: any;\n  status: number;\n  statusText: string;\n  config: Request;\n}\ninterface methodsInterface {\n  [name: string]: (\n    path: string,\n    options?: MethodConfigInterface\n  ) => Promise<ResponseInterface>;\n}\n\ninterface MethodConfigInterface {\n  PREFIX_URL?: string;\n  body?: FormData | URLSearchParams;\n  json?: JSON;\n  headers?: Headers;\n  responseType?: string;\n}\n\nclass BHR {\n  constructor(\n    protected __options: OptionsInterface = {},\n    protected __methodsConfig\n  ) {\n    this.__options = __options;\n    this.__methodsConfig = __methodsConfig;\n  }\n\n  /**\n   * TODO: This Block of code need to be refactored it may cause us a problem in the future.\n   *\n   * Parse the given URI\n   */\n  protected get __parseURI(): URL {\n    try {\n      return new URL(\n        !Object.hasOwnProperty.call(this.__options, \"PREFIX_URL\")\n          ? this.__methodsConfig.path\n          : (typeof this.__options.PREFIX_URL === \"object\" &&\n            this.__options.PREFIX_URL !== null\n              ? this.__methodsConfig.PREFIX_URL\n                ? this.__options.PREFIX_URL[this.__methodsConfig.PREFIX_URL]\n                : Object.values(this.__options.PREFIX_URL)[0]\n              : this.__options.PREFIX_URL ?? this.__methodsConfig.PREFIX_URL) +\n            this.__methodsConfig.path\n      );\n    } catch (error) {\n      throw new TypeError(error);\n    }\n  }\n\n  protected get __configuration(): Request {\n    const headersConfig = new Headers(this.__methodsConfig.headers);\n\n    /**\n     * if body is json, then set headers to content-type JSON\n     */\n    if (\n      [\"post\", \"put\", \"patch\"].includes(this.__methodsConfig.method) &&\n      Object.hasOwnProperty.call(this.__methodsConfig, \"json\") &&\n      !Object.hasOwnProperty.call(\n        this.__methodsConfig,\n        \"headers['Content-Type']\"\n      )\n    ) {\n      headersConfig.append(\"Content-Type\", \"application/json; charset=UTF-8\");\n    }\n\n    return new Request(this.__parseURI.href, {\n      method: this.__methodsConfig.method.toLocaleUpperCase(),\n      headers: headersConfig,\n      /*\n       * Note: The body type can only be a Blob, BufferSource, FormData, URLSearchParams,\n       * USVString or ReadableStream type,\n       * so for adding a JSON object to the payload you need to stringify that object.\n       */\n      body: Object.hasOwnProperty.call(this.__methodsConfig, \"json\")\n        ? JSON.stringify(this.__methodsConfig.json)\n        : this.__methodsConfig.body, // body data type must match \"Content-Type\" header\n    });\n  }\n\n  /**\n   * HttpAdapter for making http requests ðŸ¦… to the given API'S.\n   *\n   * @returns {Promise<ResponseInterface>}\n   */\n  httpAdapter() {\n    const response = new Response();\n\n    this.__methodsConfig.responseType === undefined\n      ? (this.__methodsConfig.responseType = \"json\")\n      : null;\n\n    if (this.__methodsConfig.responseType in response) {\n      const requestConfig = this.__configuration;\n\n      return fetch(requestConfig).then(async (res) => {\n        /**\n         * Retrieve response Header.\n         *\n         * @param headers\n         * @returns Response Headers\n         */\n        const retrieveHeaders = (headers: Record<string, unknown> = {}) => {\n          for (const pair of res.headers.entries()) {\n            headers[pair[0]] = pair[1];\n          }\n\n          return headers;\n        };\n\n        // Response Schema\n        const response: ResponseInterface = {\n          data: await res.json(),\n          headers: retrieveHeaders(),\n          status: res.status,\n          statusText: res.statusText,\n          config: requestConfig,\n        };\n\n        return response;\n      });\n    }\n    throw new Error(\"Response type not supported\");\n  }\n}\n\n/**\n * Create new instance for the given configuration.\n *\n * @param {OptionsInterface} config - PREFIX_URL { API: string: URI: string}\n *\n * @returns {methodsInterface} - new instance of BHR\n */\nexport function createNewInstance(config?: OptionsInterface): methodsInterface {\n  const methods: string[] = [\n    \"get\",\n    \"head\",\n    \"put\",\n    \"delete\",\n    \"post\",\n    \"patch\",\n    \"options\",\n  ]; // All the HTTP request methods.\n\n  const instance: methodsInterface = {};\n\n  /**\n   * Build methods shortcut *Http.get()*.\n   */\n  for (let index = 0; index <= methods.length - 1; index++) {\n    const method = methods[index];\n\n    instance[method] = (path: string, options?: MethodConfigInterface) => {\n      return new BHR(config, {\n        method: method,\n        path,\n        ...options,\n      }).httpAdapter();\n    };\n  }\n\n  return instance;\n}\n\nconst http = createNewInstance();\n\nexport default http;\n"],"names":[],"version":3,"file":"types.d.ts.map","sourceRoot":"../"}