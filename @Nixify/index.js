import { d, a, f, e } from './chunk-IQKJMYM3.js';
import { a as a$1 } from './chunk-XRZHORBG.js';
import './chunk-45JH5YAD.js';
import { a as a$3 } from './chunk-3TTC6GGP.js';
import { a as a$2 } from './chunk-OP7QQHAQ.js';

var T=["get","head","put","delete","post","patch","options"],w={json:"application/json",text:"text/*",formData:"multipart/form-data",arrayBuffer:"*/*",blob:"*/*"},m=t=>{if(t.url.protocol!=="https:"&&t.url.protocol!=="http:")throw new TypeError(`Unsupported protocol, ${t.url.protocol}`);let s=e(t);return new Request(t.url.toString(),s)},b=async(t,s)=>(s?.hooks?.beforeRequest&&await s.hooks.beforeRequest(t),s.timeout===!1?await fetch(t.clone()):a$3(t.clone(),s.abortController,s.timeout)),q=async(t,s,p)=>{let n=f(t,p,s),o=m(n),e=await b(o,n);if(t?.hooks?.afterResponse&&(delete n.abortController,e.json=async()=>a$1.parse(await e.clone().text()),await t.hooks.afterResponse(o,e,n)),!e.ok)throw new a$2(e.clone(),o);let r={data:null,headers:e.headers,status:e.status,statusText:e.statusText,config:o},a=e.clone(),h=async()=>{if(n.responseType==="json"){if(e.status===204)return "";let u=await a.text();return u.length===0?"":a$1.parse(u)}return await a[n.responseType]()};if(n.responseType)try{r.data=await h();}catch{throw new TypeError(`Unsupported response type "${n.responseType}" specified in the request. The Content-Type of the response is "${e.headers.get("Content-Type")}".`)}return r},k=t=>{let s={};return T.forEach(p=>{s[p]=(n,o)=>{let e=o?.responseType||"json",r={...Object.fromEntries(Object.entries(w).map(([a,h])=>[a,()=>(d(t.headers=t?.headers||{},{accept:h}),e=a,r)])),then(...a){return q(t,p,{path:n,responseType:e,...o}).then(...a)},catch(a){return r.then().catch(a)}};return r};}),s},j=t=>{let s=Object.fromEntries(Object.entries(t||{default:{}}).map(([o,e])=>[o,{...k(e),beforeRequest:r=>{if(e?.hooks?.beforeRequest)throw new TypeError("beforeRequest has already been invoked within configuration.");e.hooks={},e.hooks.beforeRequest=r;},afterResponse:r=>{if(e?.hooks?.afterResponse)throw new TypeError("afterResponse has already been invoked within configuration.");e.hooks={},e.hooks.afterResponse=r;},setHeaders:r=>d(e.headers=e.headers||{},r)}])),p=o=>Object.values(s).forEach(o);return a(t)?{...s.default}:{...s,...s[Object.keys(s)[0]],beforeRequest:o=>p(e=>e.beforeRequest(o)),afterResponse:o=>p(e=>e.afterResponse(o)),setHeaders:o=>p(e=>e.setHeaders(o))}},x={create:j};

export { x as default };
