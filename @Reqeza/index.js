import { b as b$1 } from './chunk-BKRRF6DW.js';
import { c, a, b as b$3 } from './chunk-JGXKVBPK.js';
import { b as b$2 } from './chunk-45JH5YAD.js';
import './chunk-D22QKJZO.js';

var l={},T=(r,e,a)=>{let s=new URL(e.path,r?.url??void 0);if(s.protocol!=="https:"&&s.protocol!=="http:")throw new TypeError(`Unsupported protocol, ${s.protocol}`);if(e.signal&&!(e.signal instanceof AbortSignal))throw new TypeError(typeof e.signal+" received for signal, but expected an AbortSignal");e?.qs&&(s.search=b$2.stringify(e.qs,r?.qs));let t=new Headers({...l,...r?.headers});return e?.json&&(e.body=JSON.stringify(e.json),t.append("Content-Type","application/json; charset=UTF-8"),delete e.json),e?.body instanceof URLSearchParams&&t.append("Content-Type","application/x-www-form-urlencoded;charset=utf-8"),e.headers&&(t=b$3(t,e.headers)),new Request(s.toString(),{method:a.toLocaleUpperCase(),headers:t,body:e.body,signal:e.signal,cache:e.cache,credentials:e.credentials,integrity:e.integrity,keepalive:e.keepalive,mode:e.mode,redirect:e.redirect,referrer:e.referrer,referrerPolicy:e.referrerPolicy})},b=async(r,e,a)=>{let s=T(r,a,e);return r?.hooks&&await r.hooks.beforeRequest(s),fetch(s).then(t=>b$1(t,s,r)).then(async t=>{let p={headers:(()=>{let o={};for(let c of t.headers.entries())o[c[0]]=c[1];return o})(),status:t.status,statusText:t.statusText,config:s};if(a.responseType)try{p.data=await t[a.responseType]();}catch{throw new Error(`Unsupported response type "${a.responseType}" specified in the request. The Content-Type of the response is "${t.headers.get("Content-Type")}".`)}else p.data=await t.json();return p})},f=r=>{let e=["get","head","put","delete","post","patch","options"],a={json:"application/json",text:"text/*",formData:"multipart/form-data",arrayBuffer:"*/*",blob:"*/*"},s={};return e.forEach(t=>{s[t]=(n,p)=>{let o="json",c$1={...Object.assign({},...Object.entries(a).map(([i,q])=>({[i]:()=>(c(l,{accept:q}),o=i,c$1)}))),then(i){b(r,t,{path:n,responseType:o,...p}).then(i);}};return c$1};}),s},w=r=>{let e=Object.fromEntries(Object.entries(r||{default:{}}).map(([s,t])=>[s,{...f(t),beforeRequest:n=>{t.hooks={},t.hooks.beforeRequest=n;},setHeaders:n=>c(t.headers=t.headers||{},n)}]));return a(r)?{...e.default}:{...e,...e[Object.keys(e)[0]],setHeaders:s=>c(l,s)}},S={create:w};

export { S as default };
