{"version":3,"sources":["../src/utils/errors.ts","../src/utils/index.ts","../src/index.ts"],"sourcesContent":["export class ValidationError extends Error {\n  constructor(message) {\n    super(message);\n    this.name = \"ValidationError\";\n    this.message = message;\n  }\n\n  toJSON() {\n    return {\n      error: {\n        name: this.name,\n        message: this.message,\n        stacktrace: this.stack,\n      },\n    };\n  }\n}\n\nexport function ResponseError(response) {\n  if (!response.ok) {\n    return new ValidationError(response.statusText);\n  }\n\n  return response;\n}\n","export { ValidationError, ResponseError } from \"./errors\";\n\nexport function mergeObjects(target = {}, source) {\n  return Object.assign(target, ...source);\n}\n\nexport function isNullOrEmpty(target: object) {\n  return (\n    target === null || target === undefined || Object.keys(target).length === 0\n  );\n}\n\nexport function has(target: object, key: string): boolean {\n  return isNullOrEmpty(target)\n    ? false\n    : Object.hasOwnProperty.call(target, key);\n}\n","/* eslint-disable @typescript-eslint/no-explicit-any */\nimport {\n  CreateNewInstance,\n  MethodConfig,\n  Options,\n  RequestMethods,\n  RequestMethodsType,\n  ResponseInterface,\n  queryType,\n} from \"./interfaces\";\nimport { ResponseError, has } from \"./utils\";\n\nconst __configuration = (\n  config: Options,\n  methodConfig: MethodConfig\n): Request => {\n  const __parseURI = new URL(\n    methodConfig.path,\n    !has(config, \"PREFIX_URL\") || config.PREFIX_URL === null\n      ? undefined\n      : typeof config.PREFIX_URL === \"object\" && methodConfig.PREFIX_URL\n      ? config.PREFIX_URL[methodConfig.PREFIX_URL]\n      : Object.values(config.PREFIX_URL)[0]\n  );\n\n  // https://felixgerschau.com/js-manipulate-url-search-params/\n  // Add queries to the url\n  has(methodConfig, \"qs\")\n    ? (__parseURI.search = new URLSearchParams(\n        methodConfig.qs as queryType\n      ).toString())\n    : null;\n\n  const headersConfig = new Headers({\n    ...config?.headers,\n    ...methodConfig?.headers,\n  });\n\n  /**\n   * if body is json, then set headers to content-type JSON\n   */\n  if (\n    [\"post\", \"put\", \"patch\"].includes(methodConfig.method) &&\n    has(methodConfig, \"json\") &&\n    !has(methodConfig, \"headers['Content-Type']\")\n  ) {\n    headersConfig.append(\"Content-Type\", \"application/json; charset=UTF-8\");\n  }\n\n  return new Request(__parseURI.toString(), {\n    method: methodConfig.method.toLocaleUpperCase(),\n    credentials: \"same-origin\",\n    headers: headersConfig,\n    /*\n     * Note: The body type can only be a Blob, BufferSource, FormData, URLSearchParams,\n     * USVString or ReadableStream type,\n     * so for adding a JSON object to the payload you need to stringify that object.\n     */\n    body: Object.hasOwnProperty.call(methodConfig, \"json\")\n      ? JSON.stringify(methodConfig.json)\n      : methodConfig.body, // body data type must match \"Content-Type\" header\n\n    // Cancel request\n    signal: methodConfig.signal,\n  });\n};\n\n/**\n * HttpAdapter for making http requests ðŸ¦… to the given API'S.\n *\n * @returns {Promise<ResponseInterface>}\n */\nconst httpAdapter = async <R>(config: Options, methodConfig: MethodConfig) => {\n  const requestConfig = __configuration(config, methodConfig);\n\n  // Call the beforeRequest hook for the main config if it exists\n  config?.hooks?.beforeRequest &&\n    (await config.hooks.beforeRequest(requestConfig));\n\n  // Call the beforeRequest hook for the method config if it exists\n  methodConfig?.hooks?.beforeRequest &&\n    (await methodConfig.hooks.beforeRequest(requestConfig));\n\n  return fetch(requestConfig)\n    .then(ResponseError)\n    .then(async (res) => {\n      /**\n       * Retrieve response Header.\n       *\n       * @param headers\n       * @returns Response Headers\n       */\n      const retrieveHeaders = () => {\n        const headers = {};\n        for (const pair of res.headers.entries()) {\n          headers[pair[0]] = pair[1];\n        }\n\n        return headers;\n      };\n\n      // Response Schema\n      const response: ResponseInterface<R> = {\n        data: await res[methodConfig.responseType](),\n        headers: retrieveHeaders(),\n        status: res.status,\n        statusText: res.statusText,\n        config: requestConfig,\n      };\n\n      return response;\n    });\n};\n\nconst Reqeza: CreateNewInstance = {\n  /**\n   * Create new instance for the given configuration.\n   *\n   * @param {Options} config - PREFIX_URL { API: string: URI: string}\n   *\n   * @returns {Methods} - new instance of Http\n   *\n   * @example\n   * const http = Reqeza.create({\n   *  PREFIX_URL: {\n   *    API: \"https://api.github.com\"\n   *  }\n   * })\n   */\n\n  create(config?: Options): RequestMethods {\n    // All the HTTP request methods.\n    const METHODS = [\n      \"get\",\n      \"head\",\n      \"put\",\n      \"delete\",\n      \"post\",\n      \"patch\",\n      \"options\",\n    ];\n\n    const responseTypes = [\"json\", \"text\", \"blob\", \"arrayBuffer\", \"formData\"];\n\n    let headers = {}; // Initial headers\n\n    const Reqeza = {\n      setHeaders: (newHeaders: Headers) => {\n        headers = { ...headers, ...newHeaders };\n      },\n    };\n\n    /**\n     * Build methods shortcut *Http.get().text()*.\n     */\n    METHODS.forEach((method) => {\n      Reqeza[method] = (\n        path: string,\n        options?: MethodConfig\n      ): RequestMethodsType => {\n        let responseType = \"json\";\n\n        // Response types methods generator.\n        const responseHandlers = {\n          ...Object.assign(\n            {},\n            ...responseTypes.map((typeName) => ({\n              [typeName]: () => {\n                responseType = typeName;\n\n                return responseHandlers;\n              },\n            }))\n          ),\n          // https://javascript.plainenglish.io/the-benefit-of-the-thenable-object-in-javascript-78107b697211\n          then(callback) {\n            httpAdapter(config, {\n              path,\n              method,\n              headers,\n              responseType,\n              ...options,\n            }).then(callback);\n          },\n        };\n\n        return responseHandlers;\n      };\n    });\n\n    return Reqeza as RequestMethods;\n  },\n};\n\n// Merge request methods with Reqeza Object.\nexport default { ...Reqeza, ...Reqeza.create() };\n"],"mappings":"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","names":["ValidationError","message","ResponseError","response","isNullOrEmpty","target","has","key","__configuration","config","methodConfig","__parseURI","has","headersConfig","__spreadValues","httpAdapter","_a","_b","requestConfig","ResponseError","res","retrieveHeaders","headers","pair","Reqeza","METHODS","responseTypes","newHeaders","method","path","options","responseType","responseHandlers","__spreadProps","typeName","callback","src_default"]}